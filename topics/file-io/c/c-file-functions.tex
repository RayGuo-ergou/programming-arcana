\clearpage
\subsection{C File Functions} % (fold)
\label{sub:c_file_functions}

There are a number of functions and procedures in the \textbf{stdio.h} header that will give you the ability to read and write data from files.

\subsubsection{Opening a file} % (fold)
\label{ssub:opening_a_file}

Before you can interact with a file the first step will be to open the file. This is done with the \texttt{fopen} function. This function will return a FILE pointer you can then use to interact with the file.

\begin{table}[h]
  \centering
  \begin{tabular}{|c|p{9.5cm}|}
    \hline
    \multicolumn{2}{|c|}{\textbf{Function Prototype}} \\
    \hline
    \multicolumn{2}{|c|}{} \\
    \multicolumn{2}{|c|}{\texttt{FILE *fopen( const char *filename, const char *mode )}} \\
    \multicolumn{2}{|c|}{} \\
    \hline
    \multicolumn{2}{|c|}{\textbf{Returns}} \\
    \hline
    \texttt{FILE *} & If successful this returns a pointer to the file stream opened, otherwise it returns NULL. \\
    \hline
    \textbf{Parameter} & \textbf{Description} \\
    \hline
    \texttt{ filename } & The name of the file to open. This can include a relative or absolute path to the file. \\
    & \\
    \texttt{ mode } & Indicates the kind of operations that can be performed on the file. Mode should be one of the following:\\
    & 
    \begin{tabular}{|l|p{7cm}|}
      \hline
      \textbf{mode} & \textbf{description} \\
      \hline
      \texttt{"r"} & Open the file for reading. The file must exist.\\
      \hline
      \texttt{"w"} & Open the file for writing. This will create a new file, or replace an existing file.\\
      \hline
      \texttt{"a"} & Open the file for appending data. This will append data to an existing file, or create a new file if it does not exist.\\ 
      \hline
      \texttt{"r+"} & Open the file for reading, and writing. The file must exist. \\
      \hline
      \texttt{"w+"} & Open the file for writing, and reading. This will create a new file, replacing any existing files.\\
      \hline
      \texttt{"a+"} & Open the file for appending, and reading. This ensures that all write operations are always performed at the end of the file. \\
     \hline
    \end{tabular}
    
     \\
    \hline
  \end{tabular}
  \caption{Details of the \texttt{fopen} function}
  \label{tbl:fopen}
\end{table}

\mynote{
\begin{itemize}
  \item Remember to check that \texttt{fopen} has returned you a valid pointer, if you get back NULL then it failed to open the file.
  \item For binary files you can append a \texttt{b} to the mode. For example, to open a binary file for reading you use the mode \texttt{"rb"}, to open for writing and reading you use \texttt{"w+b"}.
\end{itemize}
}

% subsubsection opening_a_file (end)

\clearpage
\subsubsection{Closing a file} % (fold)
\label{ssub:closing_a_file}

Once you have opened a file it is important that you also close it. The \texttt{fclose} function can be used to close an opened file.

\begin{table}[h]
  \centering
  \begin{tabular}{|c|p{9.5cm}|}
    \hline
    \multicolumn{2}{|c|}{\textbf{Function Prototype}} \\
    \hline
    \multicolumn{2}{|c|}{} \\
    \multicolumn{2}{|c|}{\texttt{int fclose( FILE *stream )}} \\
    \multicolumn{2}{|c|}{} \\
    \hline
    \multicolumn{2}{|c|}{\textbf{Returns}} \\
    \hline
    \texttt{int} & Returns 0 when it is successfully closed. \\
    \hline
    \textbf{Parameter} & \textbf{Description} \\
    \hline
    \texttt{ stream } & The file to close. \\
    \hline
  \end{tabular}
  \caption{Details of the \texttt{fclose} function}
  \label{tbl:fclose}
\end{table}

\mynote{
\begin{itemize}
  \item Make sure to close all opened files.
  \item Remember to check all paths through your code.
\end{itemize}
}

% subsubsection closing_a_file (end)

\subsubsection{Writing text data to file} % (fold)
\label{ssub:writing_text_data_to_file}

You can use \texttt{fprintf} to write data to a \texttt{FILE} that has been opened with write capabilities. This works the same as \texttt{printf} and \texttt{sprintf}.

\begin{table}[h]
  \centering
  \begin{tabular}{|c|p{9cm}|}
    \hline
    \multicolumn{2}{|c|}{\textbf{Function Prototype}} \\
    \hline
    \multicolumn{2}{|c|}{} \\
    \multicolumn{2}{|c|}{\texttt{int fprintf(FILE *destination, const char *format, \ldots )}} \\
    \multicolumn{2}{|c|}{} \\
    \hline
    \multicolumn{2}{|c|}{\textbf{Returns}} \\
    \hline
    \texttt{int} & The number of characters written to the \texttt{destination} by \texttt{fprintf}. \\
    \hline
    \textbf{Parameter} & \textbf{Description} \\
    \hline
    \texttt{ destination } & The FILE to write the output into.\\
    & \\
    \texttt{ format } & The text that is to be written to the file. This text may contain format tags to include other values. This is the same as \texttt{printf}, see Figure \ref{csynt:program-creation-format-string} for the syntax of the format tag. \\
    & \\
    \texttt{\ldots}   & Optional values, must have at least as many values as format tags. \\
    \hline
  \end{tabular}
  \caption{Parameters that must be passed to \texttt{fprintf}}
  \label{tbl:fprintf}
\end{table}

\mynote{
\begin{itemize}
  \item This will write the data as text to the file.
  \item The file must be opened with write permissions.
\end{itemize}
}

% subsubsection writing_data_to_file (end)

\clearpage

\subsubsection{Reading text data from file} % (fold)
\label{ssub:reading_text_data_from_file}

Reading text data from a file is similar to reading data from the Terminal or from a string. The \texttt{fscanf} function works in the same way as \texttt{printf} and \texttt{sprintf}, but writes its data to a text file.

\begin{table}[h]
  \centering
  \begin{tabular}{|c|p{9.5cm}|}
    \hline
    \multicolumn{2}{|c|}{\textbf{Function Prototype}} \\
    \hline
    \multicolumn{2}{|c|}{} \\
    \multicolumn{2}{|c|}{\texttt{int fscanf(FILE *source, const char *format, \ldots )}} \\
    \multicolumn{2}{|c|}{} \\
    \hline
    \multicolumn{2}{|c|}{\textbf{Returns}} \\
    \hline
    \texttt{int} & The number of values read by \texttt{fscanf}. \\
    \hline
    \textbf{Parameter} & \textbf{Description} \\
    \hline
    \texttt{ source } & The file from which the input is read.\\
    & \\
    \texttt{ format } & The format specifier describing what is to be read from the Terminal. This is the same as with \texttt{scanf}, see \tref{tbl:format specifiers}. \\
    & \\
    \texttt{\ldots}   & The variables into which the values will be read. There must be at least as many variables as format tags in the format specifier. \\
    \hline
  \end{tabular}
  \caption{Parameters that must be passed to \texttt{fscanf}}
  \label{tbl:fscanf}
\end{table}

\mynote{
\begin{itemize}
  \item This will read text data from the file.
  \item The file must be opened with read permissions.
\end{itemize}
}

\csection{\ccode{clst:text_io}{Example code that demonstrates writing a value and reading it back from a text file}{code/c/file-io/text_io.c}}


% subsubsection reading_data_from_file (end)


\subsubsection{Writing binary data to file} % (fold)
\label{ssub:writing_binary_data_to_file}

The \texttt{fwrite} function allows you to write binary data to a file. This requires you to pass a pointer to your data, as well as the size and number of elements you want written.

\begin{table}[h]
  \centering
  \begin{tabular}{|c|p{9cm}|}
    \hline
    \multicolumn{2}{|c|}{\textbf{Function Prototype}} \\
    \hline
    \multicolumn{2}{|c|}{} \\
    \multicolumn{2}{|c|}{\texttt{size\_t fwrite( const void *ptr, size\_t size, size\_t count, FILE *destination)}} \\
    \multicolumn{2}{|c|}{} \\
    \hline
    \multicolumn{2}{|c|}{\textbf{Returns}} \\
    \hline
    \texttt{int} & The number of elements written to the \texttt{destination} by \texttt{fwrite}. If this does not equal the \texttt{count} parameter it indicates an error occurred writing the data to the file.\\
    \hline
    \textbf{Parameter} & \textbf{Description} \\
    \hline
    \texttt{ ptr } & A pointer to the data to be saved to the file.\\
    & \\
    \texttt{ size } & The size of each element to be saved.\\
    & \\
    \texttt{ count } & The number of elements to be saved to the file.\\
    & \\
    \texttt{ destination } & The FILE to write the output into.\\
    & \\
    \hline
  \end{tabular}
  \caption{Parameters that must be passed to \texttt{fwrite}}
  \label{tbl:fwrite}
\end{table}

\mynote{
\begin{itemize}
  \item The file must be opened with write permissions.
  \item This will write the binary data to file from the values pointed to by the \texttt{prt} parameter.
\end{itemize}
}

\csection{\ccode{clst:write_binary}{Example code that writing an array of double values to a binary file.}{code/c/file-io/write_binary.c}}


% subsubsection writing_binary_data_to_file (end)

\clearpage
\subsubsection{Reading binary data from file} % (fold)
\label{ssub:reading_binary_data_from_file}

To read back binary data you need to use \texttt{fread}. This reads back a block of data from the file, and stores it in memory at a location indicated by a pointer.

\begin{table}[h]
  \centering
  \begin{tabular}{|c|p{9cm}|}
    \hline
    \multicolumn{2}{|c|}{\textbf{Function Prototype}} \\
    \hline
    \multicolumn{2}{|c|}{} \\
    \multicolumn{2}{|c|}{\texttt{size\_t fread( void *ptr, size\_t size, size\_t count, FILE *destination)}} \\
    \multicolumn{2}{|c|}{} \\
    \hline
    \multicolumn{2}{|c|}{\textbf{Returns}} \\
    \hline
    \texttt{int} & The number of elements read from the \texttt{destination} by \texttt{fprintf}. If this does not equal the \texttt{count} parameter it indicates an error occurred reading the data from the file.\\
    \hline
    \textbf{Parameter} & \textbf{Description} \\
    \hline
    \texttt{ ptr } & A pointer to the location to store the loaded data. This must be large enough to store the values loaded.\\
    & \\
    \texttt{ size } & The size of each element to be loaded.\\
    & \\
    \texttt{ count } & The number of elements to be loaded from the file.\\
    & \\
    \texttt{ destination } & The FILE to read the data from.\\
    & \\
    \hline
  \end{tabular}
  \caption{Parameters that must be passed to \texttt{fwrite}}
  \label{tbl:fread}
\end{table}

\mynote{
\begin{itemize}
  \item The file must be opened with read permissions.
  \item You must ensure that \texttt{ptr} points to sufficient space to load the data into.
\end{itemize}
}

\begin{figure}[p]
  \csection{\ccode{clst:read_binary}{Example code that reads an array of double values from a binary file.}{code/c/file-io/read_binary.c}}  
\end{figure}


% subsubsection reading_binary_data_from_file (end)

% subsection c_file_functions (end)