\chapter{Building Programs} % (fold)
\label{cha:building programs}

Welcome to the Programming Arcana\footnote{Arcana is defined as secrets or mysteries, Wiktionary defines it as ``specialized knowledge that is mysterious to the uninitiated.''. This fits well with the idea of programming, and we just think its a cool word to describe the \emph{magic} of programming!}, a book about learning to program. This book contains a number of lessons that take you from knowing nothing, or little, about programming to a position where the mysteries are revealed. By the end of the material you will be able to create your own programs and you will be ready to start learning other programming languages and approaches to software development.

This book is divided into a number of chapters, each of which introduces you to a programming task and the arcane knowledge that must be attained to understand how the task is accomplished. As with any arcane knowledge there are special terms that are used by those who know its secrets. In each chapter you will be introduced to the terms you need to understand in order to perform the current task. This will provide you with the tools you need to describe programs to other software developers, and will help you understand how the structures within your programs work to achieve their goals.

Like magic, you must learn the structure of source code, and how to use tools to convert these into executable programs. Let us begin with a simple program, a program that will greet the world.

\minitoc

% =====================================
% = Concepts - Compilers and Programs =
% =====================================
\clearpage
\section{Concepts Related to Building Programs} % (fold)
\label{sec:concepts_related_to_building_programs}

This chapter introduces several new concepts:
\begin{itemize}
  \item \nameref{sub:hello world}: A \emph{classic} program used to check that you have everything working correctly.
\end{itemize}


\input{topics/programs-and-compilers/concepts/Program}
\input{topics/programs-and-compilers/concepts/MachineCode}
\input{topics/programs-and-compilers/concepts/Assembly}
\input{topics/programs-and-compilers/concepts/Compiler}
% \input{topics/programs-and-compilers/concepts/Challenges}
\input{topics/programs-and-compilers/concepts/Terminal}
\input{topics/programs-and-compilers/concepts/HelloWorld}
\input{topics/programs-and-compilers/concepts/ConceptTaxonomy}

% section concepts_related_to_building_programs (end)


% subsection source_code (end)
\clearpage
\subsection{Compiling Code} % (fold)
\label{sub:compiling_code}

The compiler's job is to convert your source code into machine code. To do this the compiler needs a way of understanding the tasks you want the computer to perform, and the order you want them to be performed in. To help with this task the designers of the compiler define rules for how the source code for their compiler must be written. These rules define the \textbf{syntax} for the \emph{programming language} the compiler understands.

When you run the compiler you will pass to it two things: options, and the file or files you want converted to machine code. The compiler will read the files you pass it and use the language's syntax to determine the tasks you want performed. Once it has built up a model of the program it will the write machine code instructions into a program file. When the compiler finishes you can then run the program file and see the computer perform the tasks coded in the source code.

\begin{multicols}{2}
  \bashcode{lst:compile-hello-world-c}{Compiling C code.}{code/c/program-creation/compile-hello-world.sh}
  \columnbreak
  \bashcode{lst:compile-hello-world-pas}{Compiling Pascal code.}{code/pascal/program-creation/compile-hello-world.sh}
\end{multicols}

\csection{There are many different C compilers. The one we have used in Listing \ref{lst:compile-hello-world-c} is the \textbf{gcc} compiler, the \textbf{GNU C Compiler}. When you call the compiler you can use the \emph{-o name} option to tell it the name of the program file to create. In our example this will compile the code in \emph{helloworld.c} and save the machine code into a program called \emph{hello}.}

\passection{Listing \ref{lst:compile-hello-world-pas} shows the instructions to run the \textbf{fpc} compiler. FPC is the \textbf{Free Pascal Compiler}, which can compile a number of different versions of the Pascal language. The \emph{-S2} option is used to tell FPC to compile using the latest `Free Pascal' version of the language. In our example this will compile the code in \emph{HelloWorld.pas} and save the machine code into a program called \emph{HelloWorld}, which it gets from the name of the Pascal file.}

If the source code you try to compile does not follow all of the rules of the language then the compiler will end with an error message. These errors, called \textbf{syntax errors}, could be as small as missing a semicolon (;), or misspelling a name. When the compiler encounters these issues it does not create the executable program, but instead returns a list showing where it got to before it found an error. You can use these error messages to fix the mistakes, and then run the compiler again to generate your program.



% section the_compiler (end)

\section{Getting Setup} % (fold)
\label{sec:getting_setup}

To create programs you are going to need a couple of tools.

\begin{itemize}
  \item A \textbf{compiler} to convert your source code into machine code.
  \item A \textbf{text editor} to enter your code into.
  \item A \textbf{shell} to interact with your computer.
\end{itemize}



% section getting_setup (end)

\section{Summary} % (fold)
\label{sec:summary-compilers}

Computers can execute \textbf{machine code}, but this isn't very friendly for people to read or create. \textbf{Assembler code} provided the first layer of abstraction over machine code, giving symbolic names to the machine code instructions. This was a little easier to work with, but still required considerable work to create programs of even simple functionality. Most modern programs are written from \textbf{third generation languages} such as \textbf{C} and \textbf{Pascal}. With these languages the develop writes source code that is converted by a \textbf{compiler} into machine code.

% section summary (end)

% chapter building_programs (end)